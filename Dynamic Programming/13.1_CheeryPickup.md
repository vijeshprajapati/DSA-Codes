****Cheery Pickup I****

Problem Statement Link : https://leetcode.com/problems/cherry-pickup/

**BackTracking Solution**

Time Complexity: O(2^{N^{2}} X 2^{N^{2}})
Space Complexity : O(N^2)

*Critical Logic Warning*
Your current approach has a Greedy Trap.
By finishing the first path entirely before starting the second, you might pick a "very good" first path that leaves only "very bad" options for the second path.

```c++
#include <iostream>
#include <vector>
using namespace std;

static int maxi = 0;

void solveDownToTop(vector<vector<int>> &arr, int i, int j, int count){
    if(i < 0 || j < 0 || i >= arr.size() || j >= arr[0].size() || arr[i][j] == -1){
        return;
    }
    if(i == 0 && j == 0){
        maxi = max(count, maxi);
        return;
    }

    int cherry = arr[i][j];
    arr[i][j] = 0;
    solveDownToTop(arr, i - 1, j, count + cherry);
    solveDownToTop(arr, i, j - 1, count + cherry);
    arr[i][j] = cherry;
}

void solveTopToDown(vector<vector<int>> &arr, int i, int j, int count){
    if(i < 0 || j < 0 || i >= arr.size() || j >= arr[0].size() || arr[i][j] == -1){
        return;
    }
    if(i == arr.size() - 1 && j == arr[0].size() - 1){
        solveDownToTop(arr, i, j, count);
    }

    int cherry = arr[i][j];
    arr[i][j] = 0;
    solveTopToDown(arr, i + 1, j, count + cherry);
    solveTopToDown(arr, i, j + 1, count + cherry);
    arr[i][j] = cherry;
}

int main()
{
    vector<vector<int>> mat = {
        {0, 1, -1}, 
        {1, 0, -1}, 
        {1, 1, 1}
    };
    int m = mat.size();
    int n = mat[0].size();

    solveTopToDown(mat, 0, 0, 0);
    cout<<maxi;
}
```

**Recursive Logic**

Time Complexity: O(4^(m+n))
Space Complexity: O(m + n)

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int solve(vector<vector<int>> &arr, int r1, int c1, int r2, int c2){
    if(r1 >= arr.size() || r2 >= arr.size() || c1 >= arr[0].size() ||
        c2>= arr[0].size() || arr[r1][c1] == -1 || arr[r2][c2] == -1){
            return -1e9;
        }
    if(r1 == arr.size() - 1 && c1 == arr[0].size() - 1){
        return arr[r1][c1];
    }

    int cherries = 0;
    if(r1 == r2 && c1 == c2){
        cherries += arr[r1][c1];
    }else{
        cherries += arr[r1][c1] + arr[r2][c2];
    }
    int p1 = solve(arr, r1 + 1, c1, r2 + 1, c2); // 1 0 1 0
    int p2 = solve(arr, r1, c1 + 1, r2, c2 + 1); // 0 1 0 1
    int p3 = solve(arr, r1 + 1, c1, r2, c2 + 1); // 1 0 0 1
    int p4 = solve(arr, r1, c1 + 1, r2 + 1, c2); // 0 1 1 0

    return cherries + max({p1, p2, p3, p4});
}

int main()
{
    vector<vector<int>> mat = {
        {0, 1, -1}, 
        {1, 0, -1}, 
        {1, 1, 1}
    };
    int m = mat.size();
    int n = mat[0].size();

    cout<<solve(mat, 0, 0, 0, 0);
}
```


**Recursive & Memoised code**

Time Complexity: Reduced to O(N^{3}). There are (N * M * N) unique states, and each state takes O(1) to compute
Space Complexity: O(N^3) for the memo table


```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int solve(vector<vector<int>> &arr, int r1, int c1, int r2, vector<vector<vector<int>>> &memo){
    int c2 = (r1 + c1) - r2;
    if(r1 >= arr.size() || r2 >= arr.size() || c1 >= arr[0].size() ||
        c2>= arr[0].size() || arr[r1][c1] == -1 || arr[r2][c2] == -1){
            return -1e9;
        }
    if(r1 == arr.size() - 1 && c1 == arr[0].size() - 1){
        return arr[r1][c1];
    }
    if (memo[r1][c1][r2] != -1) return memo[r1][c1][r2];

    int cherries = 0;
    if(r1 == r2 && c1 == c2){
        cherries += arr[r1][c1];
    }else{
        cherries += arr[r1][c1] + arr[r2][c2];
    }
    int p1 = solve(arr, r1 + 1, c1, r2 + 1, memo); // 1 0 1 0
    int p2 = solve(arr, r1, c1 + 1, r2, memo); // 0 1 0 1
    int p3 = solve(arr, r1 + 1, c1, r2, memo); // 1 0 0 1
    int p4 = solve(arr, r1, c1 + 1, r2 + 1, memo); // 0 1 1 0

    return memo[r1][c1][r2] = cherries + max({p1, p2, p3, p4});
}

int main()
{
    vector<vector<int>> mat = {
        {0, 1, -1}, 
        {1, 0, -1},
        {1, 1, 1}
    };
    int m = mat.size();
    int n = mat[0].size();

    vector<vector<vector<int>>> memo(m, vector<vector<int>>(n, vector<int>(m, -1)));

    cout<<solve(mat, 0, 0, 0, memo);
}

```

**Tabulation Approach**



```c++

```

**Tabulation+ Space Optimization**


```c++

```