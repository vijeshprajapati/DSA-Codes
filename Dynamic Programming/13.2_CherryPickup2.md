****Cheery Pickup II****

Problem Statement Link : https://leetcode.com/problems/cherry-pickup-ii/description/


**Recursive Logic & Memoised Logic**

Time Complexity: O(N*M*M) * 9, At max, there will be N*M*M calls of recursion to solve a new problem and in every call, two nested loops together run for 9 times.

Space Complexity: O(N) + O(N*M*M), We are using a recursion stack space: O(N), where N is the path length and an external DP Array of size ‘N*M*M’.

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int solve(vector<vector<int>> &arr, int r1, int c1, int c2, vector<vector<vector<int>>> &memo){
    int r2 = r1;
    if(c1 >= arr[0].size() || c2>= arr[0].size() || c1 < 0 || c2 < 0){
        return -1e9;
    }
    if(r1 == arr.size() - 1){
        if(c1 == c2) return arr[r1][c1];
        return arr[r1][c1] + arr[r2][c2];
    }
    if(memo[r1][c1][c2] != -1) return memo[r1][c1][c2];
    int cherries = 0;
    if(c1 == c2){
        cherries += arr[r1][c1];
    }else{
        cherries += arr[r1][c1] + arr[r2][c2];
    }
    int p1 = solve(arr, r1 + 1, c1 + 1, c2 + 1, memo);
    int p2 = solve(arr, r1 + 1, c1 + 1, c2, memo);
    int p3 = solve(arr, r1 + 1, c1 + 1, c2 - 1, memo);
    int p4 = solve(arr, r1 + 1, c1, c2 + 1, memo);
    int p5 = solve(arr, r1 + 1, c1, c2, memo);
    int p6 = solve(arr, r1 + 1, c1, c2 - 1, memo);
    int p7 = solve(arr, r1 + 1, c1 - 1, c2 + 1, memo);
    int p8 = solve(arr, r1 + 1, c1 - 1, c2, memo);
    int p9 = solve(arr, r1 + 1, c1 - 1, c2 - 1, memo);

    return memo[r1][c1][c2] = cherries + max({p1, p2, p3, p4, p5, p6, p7, p8, p9});
}

int main()
{
    vector<vector<int>> mat = {
        {1,0,0,0,0,0,1}, 
        {2,0,0,0,0,3,0},
        {2,0,9,0,0,0,0},
        {0,3,0,5,4,0,0},
        {1,0,2,3,0,0,6}
    };
    int m = mat.size();
    int n = mat[0].size();

    vector<vector<vector<int>>> memo(m, vector<vector<int>>(n, vector<int>(n, -1)));

    cout<<solve(mat, 0, 0, n - 1, memo);
}
```


**Recursive & Memoised code 9 calls code improvised**

Time Complexity: O(N*M*M) * 9, At max, there will be N*M*M calls of recursion to solve a new problem and in every call, two nested loops together run for 9 times.

Space Complexity: O(N) + O(N*M*M), We are using a recursion stack space: O(N), where N is the path length and an external DP Array of size ‘N*M*M’.


```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int solve(vector<vector<int>> &arr, int r1, int c1, int c2, vector<vector<vector<int>>> &memo){
    int r2 = r1;
    if(c1 >= arr[0].size() || c2>= arr[0].size() || c1 < 0 || c2 < 0){
        return -1e9;
    }
    if(r1 == arr.size() - 1){
        if(c1 == c2) return arr[r1][c1];
        return arr[r1][c1] + arr[r2][c2];
    }
    if(memo[r1][c1][c2] != -1) return memo[r1][c1][c2];
    int cherries = 0;
    if(c1 == c2){
        cherries += arr[r1][c1];
    }else{
        cherries += arr[r1][c1] + arr[r2][c2];
    }
    int maxi = -1e9;
    for(int di = -1; di <= 1; di++){
        for(int dj = -1; dj <= 1; dj++){ 
            maxi = max(maxi, cherries + solve(arr, r1 + 1, c1 + di, c2 + dj, memo));
        }
    }
    return memo[r1][c1][c2] = maxi;
}

int main()
{
    vector<vector<int>> mat = {
        {1,0,0,0,0,0,1}, 
        {2,0,0,0,0,3,0},
        {2,0,9,0,0,0,0},
        {0,3,0,5,4,0,0},
        {1,0,2,3,0,0,6}
    };
    int m = mat.size();
    int n = mat[0].size();

    vector<vector<vector<int>>> memo(m, vector<vector<int>>(n, vector<int>(n, -1)));

    cout<<solve(mat, 0, 0, n - 1, memo);
}

```

**Tabulation Approach**
Time Complexity: O(N*M*M)*9, The outer nested loops run for (N*M*M) times and the inner two nested loops run for 9 times.

Space Complexity: O(N*M*M), We are using an external array of size ‘N*M*M’. The stack space will be eliminated.


```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    vector<vector<int>> mat = {
        {1,0,0,0,0,0,1}, 
        {2,0,0,0,0,3,0},
        {2,0,9,0,0,0,0},
        {0,3,0,5,4,0,0},
        {1,0,2,3,0,0,6}
    };
    int m = mat.size();
    int n = mat[0].size();

    vector<vector<vector<int>>> dp(m, vector<vector<int>>(n, vector<int>(n, -1)));

    for(int j1 = 0; j1 < n; j1++){
        for(int j2 = 0; j2 < n; j2++){
            if(j1 == j2) dp[m - 1][j1][j2] = mat[m - 1][j1];
            else dp[m - 1][j1][j2] = mat[m - 1][j1] + mat[m - 1][j2];
        }
    }

    for(int i = m - 2; i >= 0; i--){
        for(int j1 = n - 1; j1 >= 0; j1--){
            for(int j2 = n - 1; j2 >= 0; j2--){
                int cherries = 0;
                if(j1 == j2){
                    cherries += mat[i][j1];
                }else{
                    cherries += mat[i][j1] + mat[i][j2];
                }
                int maxi = -1e9;
                for(int di = -1; di <= 1; di++){
                    for(int dj = -1; dj <= 1; dj++){
                        if(j1 + di >= 0 && j2 + dj >= 0 && j1 + di < n && j2 + dj < n) 
                            maxi = max(maxi, cherries + dp[i + 1][j1 + di][j2 + dj]);
                        else
                            maxi = max(maxi, (int)-1e9);
                    }
                }
                dp[i][j1][j2] = maxi;
            }
        }
    }

    cout<<dp[0][0][n - 1];

}
```

**Tabulation+ Space Optimization**

Time Complexity: O(N*M*M)*9, The outer nested loops run for (N*M*M) times and the inner two nested loops run for 9 times.

Space Complexity: O(M*M), We are using an external array of size ‘M*M’.

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main()
{
    vector<vector<int>> mat = {
        {1,0,0,0,0,0,1}, 
        {2,0,0,0,0,3,0},
        {2,0,9,0,0,0,0},
        {0,3,0,5,4,0,0},
        {1,0,2,3,0,0,6}
    };
    int m = mat.size();
    int n = mat[0].size();

    vector<vector<int>> front(n, vector<int>(n, -1));
    vector<vector<int>> curr(n, vector<int>(n, -1));

    for(int j1 = 0; j1 < n; j1++){
        for(int j2 = 0; j2 < n; j2++){
            if(j1 == j2) front[j1][j2] = mat[m - 1][j1];
            else front[j1][j2] = mat[m - 1][j1] + mat[m - 1][j2];
        }
    }

    for(int i = m - 2; i >= 0; i--){
        for(int j1 = n - 1; j1 >= 0; j1--){
            for(int j2 = n - 1; j2 >= 0; j2--){
                int cherries = 0;
                if(j1 == j2){
                    cherries += mat[i][j1];
                }else{
                    cherries += mat[i][j1] + mat[i][j2];
                }
                int maxi = -1e9;
                for(int di = -1; di <= 1; di++){
                    for(int dj = -1; dj <= 1; dj++){
                        if(j1 + di >= 0 && j2 + dj >= 0 && j1 + di < n && j2 + dj < n) 
                            maxi = max(maxi, cherries + front[j1 + di][j2 + dj]);
                        else
                            maxi = max(maxi, (int)-1e9);
                    }
                }
                curr[j1][j2] = maxi;
            }
        }
        front = curr;
    }

    cout<<curr[0][n - 1];

}
```