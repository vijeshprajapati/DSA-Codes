****Cheery Pickup II****

Problem Statement Link : https://leetcode.com/problems/cherry-pickup-ii/description/


**Recursive Logic & Memoised Logic**

Time Complexity: O(N*M*M) * 9, At max, there will be N*M*M calls of recursion to solve a new problem and in every call, two nested loops together run for 9 times.

Space Complexity: O(N) + O(N*M*M), We are using a recursion stack space: O(N), where N is the path length and an external DP Array of size ‘N*M*M’.

```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int solve(vector<vector<int>> &arr, int r1, int c1, int c2, vector<vector<vector<int>>> &memo){
    int r2 = r1;
    if(c1 >= arr[0].size() || c2>= arr[0].size() || c1 < 0 || c2 < 0){
        return -1e9;
    }
    if(r1 == arr.size() - 1){
        if(c1 == c2) return arr[r1][c1];
        return arr[r1][c1] + arr[r2][c2];
    }
    if(memo[r1][c1][c2] != -1) return memo[r1][c1][c2];
    int cherries = 0;
    if(c1 == c2){
        cherries += arr[r1][c1];
    }else{
        cherries += arr[r1][c1] + arr[r2][c2];
    }
    int p1 = solve(arr, r1 + 1, c1 + 1, c2 + 1, memo);
    int p2 = solve(arr, r1 + 1, c1 + 1, c2, memo);
    int p3 = solve(arr, r1 + 1, c1 + 1, c2 - 1, memo);
    int p4 = solve(arr, r1 + 1, c1, c2 + 1, memo);
    int p5 = solve(arr, r1 + 1, c1, c2, memo);
    int p6 = solve(arr, r1 + 1, c1, c2 - 1, memo);
    int p7 = solve(arr, r1 + 1, c1 - 1, c2 + 1, memo);
    int p8 = solve(arr, r1 + 1, c1 - 1, c2, memo);
    int p9 = solve(arr, r1 + 1, c1 - 1, c2 - 1, memo);

    return memo[r1][c1][c2] = cherries + max({p1, p2, p3, p4, p5, p6, p7, p8, p9});
}

int main()
{
    vector<vector<int>> mat = {
        {1,0,0,0,0,0,1}, 
        {2,0,0,0,0,3,0},
        {2,0,9,0,0,0,0},
        {0,3,0,5,4,0,0},
        {1,0,2,3,0,0,6}
    };
    int m = mat.size();
    int n = mat[0].size();

    vector<vector<vector<int>>> memo(m, vector<vector<int>>(n, vector<int>(n, -1)));

    cout<<solve(mat, 0, 0, n - 1, memo);
}
```


**Recursive & Memoised code 9 calls code improvised**

Time Complexity: O(N*M*M) * 9, At max, there will be N*M*M calls of recursion to solve a new problem and in every call, two nested loops together run for 9 times.

Space Complexity: O(N) + O(N*M*M), We are using a recursion stack space: O(N), where N is the path length and an external DP Array of size ‘N*M*M’.


```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int solve(vector<vector<int>> &arr, int r1, int c1, int c2, vector<vector<vector<int>>> &memo){
    int r2 = r1;
    if(c1 >= arr[0].size() || c2>= arr[0].size() || c1 < 0 || c2 < 0){
        return -1e9;
    }
    if(r1 == arr.size() - 1){
        if(c1 == c2) return arr[r1][c1];
        return arr[r1][c1] + arr[r2][c2];
    }
    if(memo[r1][c1][c2] != -1) return memo[r1][c1][c2];
    int cherries = 0;
    if(c1 == c2){
        cherries += arr[r1][c1];
    }else{
        cherries += arr[r1][c1] + arr[r2][c2];
    }
    int maxi = -1e9;
    for(int di = -1; di <= 1; di++){
        for(int dj = -1; dj <= 1; dj++){ 
            maxi = max(maxi, cherries + solve(arr, r1 + 1, c1 + di, c2 + dj, memo));
        }
    }
    return memo[r1][c1][c2] = maxi;
}

int main()
{
    vector<vector<int>> mat = {
        {1,0,0,0,0,0,1}, 
        {2,0,0,0,0,3,0},
        {2,0,9,0,0,0,0},
        {0,3,0,5,4,0,0},
        {1,0,2,3,0,0,6}
    };
    int m = mat.size();
    int n = mat[0].size();

    vector<vector<vector<int>>> memo(m, vector<vector<int>>(n, vector<int>(n, -1)));

    cout<<solve(mat, 0, 0, n - 1, memo);
}

```

**Tabulation Approach**



```c++

```

**Tabulation+ Space Optimization**


```c++

```